//
// Created by wangxn on 2016/4/8.
//

#ifndef DATA_STRUCTURE_C_SORT_H
#define DATA_STRUCTURE_C_SORT_H


/**
 * 插入排序
 * 基本原理: 就是每次从没有排序的数据集中取出一个元素,插入已经排好序的数据集中
 *
 * 虽然实现插入排序用到连续的存储空间,但是他也可以用链表来实现,并且效率不差(并不是所有的排序都可以使用链表来实现)
 *
 * 操作方式:
 *      使用一个嵌套循环.
 *          外部循环使用标号j来控制元素,使元素从无序数据集中插入有序数据集中.
 *          由于待插入的元素总是会被插入有序数据集的右边,
 *          因此也可以认为j是data种分隔有序元素集合和无序元素集合的界线
 *          对于每个处于位置j的元素,都会使用变量i来向后查找元素将要放置的位置.
 *          当向后查找数据时,每个处于位置i的元素都要向后移动一位,以保证预留出足够的空间来插入新元素.
 *          一旦到达无序数据集的尾部,data就是一个有序数据集了
 *
 *  @param: data  连续的存储空间
 *  @param: size  空间的数据数量
 *  @param: esize
 *  @param: compare
 */
int insert_sort(void *data, int size, int esize, int (*compare)(const void *key1, const void *key2));

/**
 *  在处理到大型数据集时,快速排序是一个比较好的选择
 *  快速排序是一种分治排序算法
 *      分:  设定一个分割值并将数据分为两部分
 *      治:  分别在两部分用递归的方式继续使用快速排序法
 *      合:  对分割部分排序直至完成
 *
 *  快速排序的效率,关键取决于如何选择分割值
 *
 *  选择分割值的一种行之有效的方法是通过随机选择法来选取.
 *  同时,还可以改进这种随机选择方法,方法是首先随机选择三个元素,然后选择三个元素中的中间值.
 *  这就是所谓的中位数方法, 可以保证平均情况下的性能.
 *  由于这种分割方法依赖随机数的统计特性,所以快速排序是随机算法的一个好例子
 *
 * 操作方式:
 *      通过函数partition来分割data中处于i和k之间的元素(i<k)
 *
 *      首先选取一个分割值,一旦选定分割值,就将k往data的左边移动,直到找到一个小于或者等于分割值的元素.
 *      这个元素属于左边分区.
 *      然后,将i往右边移动,直到找到一个大于或等于分割值的元素
 *      这个元素属于右边分区.
 *      一旦找到的两个元素处于错误的位置,就交换他们的位置
 *      重复这个过程,直到i和k重合
 *
 *      递归:
 *      初始时,i为0, k为size-1.
 *
 *
 * @param: data  数组
 * @param: size  数组中的元素个数
 * @param: esize 每个元素的大小
 * @param: i     i和k定义当前进行排序的两个部分,其值分别初始化为0 和size-1
 * @param: k
 * @param: compare
 * 当qksort返回时,data包含已经排序的元素
 */
int quick_sort(void *data, int size, int esize, int i ,int k, int (*compare)(const void *key1, const void *key2));

#endif //DATA_STRUCTURE_C_SORT_H
